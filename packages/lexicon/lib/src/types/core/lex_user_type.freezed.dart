// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'lex_user_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LexUserType {
  Object get data => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LexUserTypeCopyWith<$Res> {
  factory $LexUserTypeCopyWith(
          LexUserType value, $Res Function(LexUserType) then) =
      _$LexUserTypeCopyWithImpl<$Res, LexUserType>;
}

/// @nodoc
class _$LexUserTypeCopyWithImpl<$Res, $Val extends LexUserType>
    implements $LexUserTypeCopyWith<$Res> {
  _$LexUserTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LexRecordImplCopyWith<$Res> {
  factory _$$LexRecordImplCopyWith(
          _$LexRecordImpl value, $Res Function(_$LexRecordImpl) then) =
      __$$LexRecordImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexRecord data});

  $LexRecordCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexRecordImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexRecordImpl>
    implements _$$LexRecordImplCopyWith<$Res> {
  __$$LexRecordImplCopyWithImpl(
      _$LexRecordImpl _value, $Res Function(_$LexRecordImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexRecordImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexRecord,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexRecordCopyWith<$Res> get data {
    return $LexRecordCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexRecordImpl extends _LexRecord {
  const _$LexRecordImpl({required this.data}) : super._();

  @override
  final LexRecord data;

  @override
  String toString() {
    return 'LexUserType.record(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexRecordImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexRecordImplCopyWith<_$LexRecordImpl> get copyWith =>
      __$$LexRecordImplCopyWithImpl<_$LexRecordImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return record(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return record?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (record != null) {
      return record(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return record(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return record?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (record != null) {
      return record(this);
    }
    return orElse();
  }
}

abstract class _LexRecord extends LexUserType {
  const factory _LexRecord({required final LexRecord data}) = _$LexRecordImpl;
  const _LexRecord._() : super._();

  @override
  LexRecord get data;
  @JsonKey(ignore: true)
  _$$LexRecordImplCopyWith<_$LexRecordImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexXrpcQueryImplCopyWith<$Res> {
  factory _$$LexXrpcQueryImplCopyWith(
          _$LexXrpcQueryImpl value, $Res Function(_$LexXrpcQueryImpl) then) =
      __$$LexXrpcQueryImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcQuery data});

  $LexXrpcQueryCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexXrpcQueryImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexXrpcQueryImpl>
    implements _$$LexXrpcQueryImplCopyWith<$Res> {
  __$$LexXrpcQueryImplCopyWithImpl(
      _$LexXrpcQueryImpl _value, $Res Function(_$LexXrpcQueryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexXrpcQueryImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcQuery,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexXrpcQueryCopyWith<$Res> get data {
    return $LexXrpcQueryCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexXrpcQueryImpl extends _LexXrpcQuery {
  const _$LexXrpcQueryImpl({required this.data}) : super._();

  @override
  final LexXrpcQuery data;

  @override
  String toString() {
    return 'LexUserType.xrpcQuery(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexXrpcQueryImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexXrpcQueryImplCopyWith<_$LexXrpcQueryImpl> get copyWith =>
      __$$LexXrpcQueryImplCopyWithImpl<_$LexXrpcQueryImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcQuery(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcQuery?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcQuery != null) {
      return xrpcQuery(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return xrpcQuery(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return xrpcQuery?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcQuery != null) {
      return xrpcQuery(this);
    }
    return orElse();
  }
}

abstract class _LexXrpcQuery extends LexUserType {
  const factory _LexXrpcQuery({required final LexXrpcQuery data}) =
      _$LexXrpcQueryImpl;
  const _LexXrpcQuery._() : super._();

  @override
  LexXrpcQuery get data;
  @JsonKey(ignore: true)
  _$$LexXrpcQueryImplCopyWith<_$LexXrpcQueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexXrpcProcedureImplCopyWith<$Res> {
  factory _$$LexXrpcProcedureImplCopyWith(_$LexXrpcProcedureImpl value,
          $Res Function(_$LexXrpcProcedureImpl) then) =
      __$$LexXrpcProcedureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcProcedure data});

  $LexXrpcProcedureCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexXrpcProcedureImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexXrpcProcedureImpl>
    implements _$$LexXrpcProcedureImplCopyWith<$Res> {
  __$$LexXrpcProcedureImplCopyWithImpl(_$LexXrpcProcedureImpl _value,
      $Res Function(_$LexXrpcProcedureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexXrpcProcedureImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcProcedure,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexXrpcProcedureCopyWith<$Res> get data {
    return $LexXrpcProcedureCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexXrpcProcedureImpl extends _LexXrpcProcedure {
  const _$LexXrpcProcedureImpl({required this.data}) : super._();

  @override
  final LexXrpcProcedure data;

  @override
  String toString() {
    return 'LexUserType.xrpcProcedure(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexXrpcProcedureImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexXrpcProcedureImplCopyWith<_$LexXrpcProcedureImpl> get copyWith =>
      __$$LexXrpcProcedureImplCopyWithImpl<_$LexXrpcProcedureImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcProcedure(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcProcedure?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcProcedure != null) {
      return xrpcProcedure(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return xrpcProcedure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return xrpcProcedure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcProcedure != null) {
      return xrpcProcedure(this);
    }
    return orElse();
  }
}

abstract class _LexXrpcProcedure extends LexUserType {
  const factory _LexXrpcProcedure({required final LexXrpcProcedure data}) =
      _$LexXrpcProcedureImpl;
  const _LexXrpcProcedure._() : super._();

  @override
  LexXrpcProcedure get data;
  @JsonKey(ignore: true)
  _$$LexXrpcProcedureImplCopyWith<_$LexXrpcProcedureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexXrpcSubscriptionImplCopyWith<$Res> {
  factory _$$LexXrpcSubscriptionImplCopyWith(_$LexXrpcSubscriptionImpl value,
          $Res Function(_$LexXrpcSubscriptionImpl) then) =
      __$$LexXrpcSubscriptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcSubscription data});

  $LexXrpcSubscriptionCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexXrpcSubscriptionImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexXrpcSubscriptionImpl>
    implements _$$LexXrpcSubscriptionImplCopyWith<$Res> {
  __$$LexXrpcSubscriptionImplCopyWithImpl(_$LexXrpcSubscriptionImpl _value,
      $Res Function(_$LexXrpcSubscriptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexXrpcSubscriptionImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcSubscription,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexXrpcSubscriptionCopyWith<$Res> get data {
    return $LexXrpcSubscriptionCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexXrpcSubscriptionImpl extends _LexXrpcSubscription {
  const _$LexXrpcSubscriptionImpl({required this.data}) : super._();

  @override
  final LexXrpcSubscription data;

  @override
  String toString() {
    return 'LexUserType.xrpcSubscription(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexXrpcSubscriptionImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexXrpcSubscriptionImplCopyWith<_$LexXrpcSubscriptionImpl> get copyWith =>
      __$$LexXrpcSubscriptionImplCopyWithImpl<_$LexXrpcSubscriptionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcSubscription(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcSubscription?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcSubscription != null) {
      return xrpcSubscription(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return xrpcSubscription(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return xrpcSubscription?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcSubscription != null) {
      return xrpcSubscription(this);
    }
    return orElse();
  }
}

abstract class _LexXrpcSubscription extends LexUserType {
  const factory _LexXrpcSubscription(
      {required final LexXrpcSubscription data}) = _$LexXrpcSubscriptionImpl;
  const _LexXrpcSubscription._() : super._();

  @override
  LexXrpcSubscription get data;
  @JsonKey(ignore: true)
  _$$LexXrpcSubscriptionImplCopyWith<_$LexXrpcSubscriptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexBlobImplCopyWith<$Res> {
  factory _$$LexBlobImplCopyWith(
          _$LexBlobImpl value, $Res Function(_$LexBlobImpl) then) =
      __$$LexBlobImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBlob data});

  $LexBlobCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexBlobImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexBlobImpl>
    implements _$$LexBlobImplCopyWith<$Res> {
  __$$LexBlobImplCopyWithImpl(
      _$LexBlobImpl _value, $Res Function(_$LexBlobImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexBlobImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBlob,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexBlobCopyWith<$Res> get data {
    return $LexBlobCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexBlobImpl extends _LexBlob {
  const _$LexBlobImpl({required this.data}) : super._();

  @override
  final LexBlob data;

  @override
  String toString() {
    return 'LexUserType.blob(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexBlobImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexBlobImplCopyWith<_$LexBlobImpl> get copyWith =>
      __$$LexBlobImplCopyWithImpl<_$LexBlobImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return blob(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return blob?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (blob != null) {
      return blob(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return blob(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return blob?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (blob != null) {
      return blob(this);
    }
    return orElse();
  }
}

abstract class _LexBlob extends LexUserType {
  const factory _LexBlob({required final LexBlob data}) = _$LexBlobImpl;
  const _LexBlob._() : super._();

  @override
  LexBlob get data;
  @JsonKey(ignore: true)
  _$$LexBlobImplCopyWith<_$LexBlobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexArrayImplCopyWith<$Res> {
  factory _$$LexArrayImplCopyWith(
          _$LexArrayImpl value, $Res Function(_$LexArrayImpl) then) =
      __$$LexArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexArray data});

  $LexArrayCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexArrayImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexArrayImpl>
    implements _$$LexArrayImplCopyWith<$Res> {
  __$$LexArrayImplCopyWithImpl(
      _$LexArrayImpl _value, $Res Function(_$LexArrayImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexArrayImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexArray,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexArrayCopyWith<$Res> get data {
    return $LexArrayCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexArrayImpl extends _LexArray {
  const _$LexArrayImpl({required this.data}) : super._();

  @override
  final LexArray data;

  @override
  String toString() {
    return 'LexUserType.array(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexArrayImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexArrayImplCopyWith<_$LexArrayImpl> get copyWith =>
      __$$LexArrayImplCopyWithImpl<_$LexArrayImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return array(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return array?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }
}

abstract class _LexArray extends LexUserType {
  const factory _LexArray({required final LexArray data}) = _$LexArrayImpl;
  const _LexArray._() : super._();

  @override
  LexArray get data;
  @JsonKey(ignore: true)
  _$$LexArrayImplCopyWith<_$LexArrayImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexTokenImplCopyWith<$Res> {
  factory _$$LexTokenImplCopyWith(
          _$LexTokenImpl value, $Res Function(_$LexTokenImpl) then) =
      __$$LexTokenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexToken data});

  $LexTokenCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexTokenImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexTokenImpl>
    implements _$$LexTokenImplCopyWith<$Res> {
  __$$LexTokenImplCopyWithImpl(
      _$LexTokenImpl _value, $Res Function(_$LexTokenImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexTokenImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexToken,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexTokenCopyWith<$Res> get data {
    return $LexTokenCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexTokenImpl extends _LexToken {
  const _$LexTokenImpl({required this.data}) : super._();

  @override
  final LexToken data;

  @override
  String toString() {
    return 'LexUserType.token(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexTokenImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexTokenImplCopyWith<_$LexTokenImpl> get copyWith =>
      __$$LexTokenImplCopyWithImpl<_$LexTokenImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return token(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return token?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (token != null) {
      return token(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return token(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return token?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (token != null) {
      return token(this);
    }
    return orElse();
  }
}

abstract class _LexToken extends LexUserType {
  const factory _LexToken({required final LexToken data}) = _$LexTokenImpl;
  const _LexToken._() : super._();

  @override
  LexToken get data;
  @JsonKey(ignore: true)
  _$$LexTokenImplCopyWith<_$LexTokenImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexObjectImplCopyWith<$Res> {
  factory _$$LexObjectImplCopyWith(
          _$LexObjectImpl value, $Res Function(_$LexObjectImpl) then) =
      __$$LexObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexObject data});

  $LexObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexObjectImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexObjectImpl>
    implements _$$LexObjectImplCopyWith<$Res> {
  __$$LexObjectImplCopyWithImpl(
      _$LexObjectImpl _value, $Res Function(_$LexObjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexObjectImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexObject,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexObjectCopyWith<$Res> get data {
    return $LexObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexObjectImpl extends _LexObject {
  const _$LexObjectImpl({required this.data}) : super._();

  @override
  final LexObject data;

  @override
  String toString() {
    return 'LexUserType.object(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexObjectImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexObjectImplCopyWith<_$LexObjectImpl> get copyWith =>
      __$$LexObjectImplCopyWithImpl<_$LexObjectImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return object(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return object?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return object(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return object?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(this);
    }
    return orElse();
  }
}

abstract class _LexObject extends LexUserType {
  const factory _LexObject({required final LexObject data}) = _$LexObjectImpl;
  const _LexObject._() : super._();

  @override
  LexObject get data;
  @JsonKey(ignore: true)
  _$$LexObjectImplCopyWith<_$LexObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexBooleanImplCopyWith<$Res> {
  factory _$$LexBooleanImplCopyWith(
          _$LexBooleanImpl value, $Res Function(_$LexBooleanImpl) then) =
      __$$LexBooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBoolean data});

  $LexBooleanCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexBooleanImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexBooleanImpl>
    implements _$$LexBooleanImplCopyWith<$Res> {
  __$$LexBooleanImplCopyWithImpl(
      _$LexBooleanImpl _value, $Res Function(_$LexBooleanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexBooleanImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBoolean,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexBooleanCopyWith<$Res> get data {
    return $LexBooleanCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexBooleanImpl extends _LexBoolean {
  const _$LexBooleanImpl({required this.data}) : super._();

  @override
  final LexBoolean data;

  @override
  String toString() {
    return 'LexUserType.boolean(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexBooleanImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexBooleanImplCopyWith<_$LexBooleanImpl> get copyWith =>
      __$$LexBooleanImplCopyWithImpl<_$LexBooleanImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return boolean(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return boolean?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class _LexBoolean extends LexUserType {
  const factory _LexBoolean({required final LexBoolean data}) =
      _$LexBooleanImpl;
  const _LexBoolean._() : super._();

  @override
  LexBoolean get data;
  @JsonKey(ignore: true)
  _$$LexBooleanImplCopyWith<_$LexBooleanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexIntegerImplCopyWith<$Res> {
  factory _$$LexIntegerImplCopyWith(
          _$LexIntegerImpl value, $Res Function(_$LexIntegerImpl) then) =
      __$$LexIntegerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexInteger data});

  $LexIntegerCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexIntegerImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexIntegerImpl>
    implements _$$LexIntegerImplCopyWith<$Res> {
  __$$LexIntegerImplCopyWithImpl(
      _$LexIntegerImpl _value, $Res Function(_$LexIntegerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexIntegerImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexInteger,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexIntegerCopyWith<$Res> get data {
    return $LexIntegerCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexIntegerImpl extends _LexInteger {
  const _$LexIntegerImpl({required this.data}) : super._();

  @override
  final LexInteger data;

  @override
  String toString() {
    return 'LexUserType.integer(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexIntegerImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexIntegerImplCopyWith<_$LexIntegerImpl> get copyWith =>
      __$$LexIntegerImplCopyWithImpl<_$LexIntegerImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return integer(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return integer?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return integer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return integer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(this);
    }
    return orElse();
  }
}

abstract class _LexInteger extends LexUserType {
  const factory _LexInteger({required final LexInteger data}) =
      _$LexIntegerImpl;
  const _LexInteger._() : super._();

  @override
  LexInteger get data;
  @JsonKey(ignore: true)
  _$$LexIntegerImplCopyWith<_$LexIntegerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexStringImplCopyWith<$Res> {
  factory _$$LexStringImplCopyWith(
          _$LexStringImpl value, $Res Function(_$LexStringImpl) then) =
      __$$LexStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexString data});

  $LexStringCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexStringImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexStringImpl>
    implements _$$LexStringImplCopyWith<$Res> {
  __$$LexStringImplCopyWithImpl(
      _$LexStringImpl _value, $Res Function(_$LexStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexStringImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexString,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexStringCopyWith<$Res> get data {
    return $LexStringCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexStringImpl extends _LexString {
  const _$LexStringImpl({required this.data}) : super._();

  @override
  final LexString data;

  @override
  String toString() {
    return 'LexUserType.string(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexStringImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexStringImplCopyWith<_$LexStringImpl> get copyWith =>
      __$$LexStringImplCopyWithImpl<_$LexStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return string(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return string?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class _LexString extends LexUserType {
  const factory _LexString({required final LexString data}) = _$LexStringImpl;
  const _LexString._() : super._();

  @override
  LexString get data;
  @JsonKey(ignore: true)
  _$$LexStringImplCopyWith<_$LexStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexBytesImplCopyWith<$Res> {
  factory _$$LexBytesImplCopyWith(
          _$LexBytesImpl value, $Res Function(_$LexBytesImpl) then) =
      __$$LexBytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBytes data});

  $LexBytesCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexBytesImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexBytesImpl>
    implements _$$LexBytesImplCopyWith<$Res> {
  __$$LexBytesImplCopyWithImpl(
      _$LexBytesImpl _value, $Res Function(_$LexBytesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexBytesImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBytes,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexBytesCopyWith<$Res> get data {
    return $LexBytesCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexBytesImpl extends _LexBytes {
  const _$LexBytesImpl({required this.data}) : super._();

  @override
  final LexBytes data;

  @override
  String toString() {
    return 'LexUserType.bytes(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexBytesImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexBytesImplCopyWith<_$LexBytesImpl> get copyWith =>
      __$$LexBytesImplCopyWithImpl<_$LexBytesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return bytes(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return bytes?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class _LexBytes extends LexUserType {
  const factory _LexBytes({required final LexBytes data}) = _$LexBytesImpl;
  const _LexBytes._() : super._();

  @override
  LexBytes get data;
  @JsonKey(ignore: true)
  _$$LexBytesImplCopyWith<_$LexBytesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexCidLinkImplCopyWith<$Res> {
  factory _$$LexCidLinkImplCopyWith(
          _$LexCidLinkImpl value, $Res Function(_$LexCidLinkImpl) then) =
      __$$LexCidLinkImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexCidLink data});

  $LexCidLinkCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexCidLinkImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexCidLinkImpl>
    implements _$$LexCidLinkImplCopyWith<$Res> {
  __$$LexCidLinkImplCopyWithImpl(
      _$LexCidLinkImpl _value, $Res Function(_$LexCidLinkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexCidLinkImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexCidLink,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexCidLinkCopyWith<$Res> get data {
    return $LexCidLinkCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexCidLinkImpl extends _LexCidLink {
  const _$LexCidLinkImpl({required this.data}) : super._();

  @override
  final LexCidLink data;

  @override
  String toString() {
    return 'LexUserType.cidLink(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexCidLinkImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexCidLinkImplCopyWith<_$LexCidLinkImpl> get copyWith =>
      __$$LexCidLinkImplCopyWithImpl<_$LexCidLinkImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return cidLink(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return cidLink?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (cidLink != null) {
      return cidLink(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return cidLink(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return cidLink?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (cidLink != null) {
      return cidLink(this);
    }
    return orElse();
  }
}

abstract class _LexCidLink extends LexUserType {
  const factory _LexCidLink({required final LexCidLink data}) =
      _$LexCidLinkImpl;
  const _LexCidLink._() : super._();

  @override
  LexCidLink get data;
  @JsonKey(ignore: true)
  _$$LexCidLinkImplCopyWith<_$LexCidLinkImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LexUnknownImplCopyWith<$Res> {
  factory _$$LexUnknownImplCopyWith(
          _$LexUnknownImpl value, $Res Function(_$LexUnknownImpl) then) =
      __$$LexUnknownImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexUnknown data});

  $LexUnknownCopyWith<$Res> get data;
}

/// @nodoc
class __$$LexUnknownImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$LexUnknownImpl>
    implements _$$LexUnknownImplCopyWith<$Res> {
  __$$LexUnknownImplCopyWithImpl(
      _$LexUnknownImpl _value, $Res Function(_$LexUnknownImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$LexUnknownImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexUnknown,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LexUnknownCopyWith<$Res> get data {
    return $LexUnknownCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$LexUnknownImpl extends _LexUnknown {
  const _$LexUnknownImpl({required this.data}) : super._();

  @override
  final LexUnknown data;

  @override
  String toString() {
    return 'LexUserType.unknown(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LexUnknownImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LexUnknownImplCopyWith<_$LexUnknownImpl> get copyWith =>
      __$$LexUnknownImplCopyWithImpl<_$LexUnknownImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return unknown(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return unknown?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LexRecord value) record,
    required TResult Function(_LexXrpcQuery value) xrpcQuery,
    required TResult Function(_LexXrpcProcedure value) xrpcProcedure,
    required TResult Function(_LexXrpcSubscription value) xrpcSubscription,
    required TResult Function(_LexBlob value) blob,
    required TResult Function(_LexArray value) array,
    required TResult Function(_LexToken value) token,
    required TResult Function(_LexObject value) object,
    required TResult Function(_LexBoolean value) boolean,
    required TResult Function(_LexInteger value) integer,
    required TResult Function(_LexString value) string,
    required TResult Function(_LexBytes value) bytes,
    required TResult Function(_LexCidLink value) cidLink,
    required TResult Function(_LexUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LexRecord value)? record,
    TResult? Function(_LexXrpcQuery value)? xrpcQuery,
    TResult? Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult? Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult? Function(_LexBlob value)? blob,
    TResult? Function(_LexArray value)? array,
    TResult? Function(_LexToken value)? token,
    TResult? Function(_LexObject value)? object,
    TResult? Function(_LexBoolean value)? boolean,
    TResult? Function(_LexInteger value)? integer,
    TResult? Function(_LexString value)? string,
    TResult? Function(_LexBytes value)? bytes,
    TResult? Function(_LexCidLink value)? cidLink,
    TResult? Function(_LexUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LexRecord value)? record,
    TResult Function(_LexXrpcQuery value)? xrpcQuery,
    TResult Function(_LexXrpcProcedure value)? xrpcProcedure,
    TResult Function(_LexXrpcSubscription value)? xrpcSubscription,
    TResult Function(_LexBlob value)? blob,
    TResult Function(_LexArray value)? array,
    TResult Function(_LexToken value)? token,
    TResult Function(_LexObject value)? object,
    TResult Function(_LexBoolean value)? boolean,
    TResult Function(_LexInteger value)? integer,
    TResult Function(_LexString value)? string,
    TResult Function(_LexBytes value)? bytes,
    TResult Function(_LexCidLink value)? cidLink,
    TResult Function(_LexUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _LexUnknown extends LexUserType {
  const factory _LexUnknown({required final LexUnknown data}) =
      _$LexUnknownImpl;
  const _LexUnknown._() : super._();

  @override
  LexUnknown get data;
  @JsonKey(ignore: true)
  _$$LexUnknownImplCopyWith<_$LexUnknownImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
