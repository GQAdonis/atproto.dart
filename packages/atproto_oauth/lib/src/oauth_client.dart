// Copyright 2024 Shinya Kato. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided the conditions.

// ðŸŽ¯ Dart imports:
import 'dart:convert';

// ðŸ“¦ Package imports:
import 'package:http/http.dart' as http;
import 'package:pointycastle/pointycastle.dart';

// ðŸŒŽ Project imports:
import 'helper/helper.dart';
import 'helper/private_key.dart';
import 'helper/public_key.dart';
import 'oauth_exception.dart';
import 'types/client_metadata.dart';
import 'types/context.dart';
import 'types/session.dart';

/// Returns a client metadata associated with [clientId].
Future<OAuthClientMetadata> getClientMetadata(final String clientId) async {
  if (clientId.isEmpty) throw ArgumentError.notNull(clientId);
  if (Uri.tryParse(clientId) == null) throw ArgumentError.value(clientId);

  final response = await http.get(Uri.parse(clientId));

  if (response.statusCode != 200) {
    throw OAuthException(
      'Failed to get client metadata: ${response.statusCode}',
    );
  }

  return OAuthClientMetadata.fromJson(jsonDecode(response.body));
}

final class OAuthClient {
  const OAuthClient(
    this.metadata, {
    this.service = 'bsky.social',
  });

  /// Client metadata to be used during authentication.
  final OAuthClientMetadata metadata;

  /// Service for which the account to be authenticated exists.
  final String service;

  /// Returns an authorization uri and context based on identity.
  Future<(Uri, OAuthContext)> authorize(
    final String identity, {
    String? redirectUri,
    String? scope,
  }) async {
    final codeVerifier = random(46);
    final codeChallenge = hashS256(codeVerifier);
    final state = random(64);

    final response = await http.post(
      Uri.https(service, '/oauth/par'),
      body: {
        'client_id': metadata.clientId,
        'redirect_uri': redirectUri ?? metadata.redirectUris.firstOrNull,
        'login_hint': identity,
        'state': state,
        'code_challenge': codeChallenge,
        'code_challenge_method': 'S256',
        'response_type': 'code',
        'scope': scope ?? metadata.scope,
      },
    );

    if (response.statusCode != 201) {
      throw OAuthException(response.body);
    }

    return (
      Uri.https(service, '/oauth/authorize', {
        'client_id': metadata.clientId,
        'request_uri': jsonDecode(response.body)['request_uri']!,
      }),
      OAuthContext(
        codeVerifier: codeVerifier,
        state: state,
        dpopNonce: response.headers['dpop-nonce']!,
      )
    );
  }

  /// Returns an authenticated session.
  ///
  /// Pass the [callback] URL of the page redirected from
  /// the URL generated by [authorize].
  ///
  /// Pass the [context] returned from [authorize]
  /// as is if there is no reason.
  Future<OAuthSession> callback(
    final String callback,
    final OAuthContext context,
  ) async {
    if (callback.isEmpty) throw ArgumentError.notNull(callback);
    if (Uri.tryParse(callback) == null) throw ArgumentError.value(callback);

    final params = Uri.parse(callback).queryParameters;

    final stateParam = params['state'];
    if (stateParam == null) throw OAuthException('Missing "state" parameter');
    if (context.state != stateParam) {
      throw OAuthException('Unknown authorization session "$stateParam"');
    }

    final errorParam = params['error'];
    if (errorParam != null) throw OAuthException(errorParam);

    final codeParam = params['code'];
    if (codeParam == null) throw OAuthException('Missing "code" query param');

    final keyPair = getKeyPair();
    final endpoint = Uri.https(service, '/oauth/token');

    final publicKey = encodePublicKey(keyPair.publicKey as ECPublicKey);
    final privateKey = encodePrivateKey(keyPair.privateKey as ECPrivateKey);

    final dPoPHeader = getDPoPHeader(
      clientId: metadata.clientId,
      endpoint: endpoint.toString(),
      method: 'POST',
      dPoPNonce: context.dpopNonce,
      publicKey: publicKey,
      privateKey: privateKey,
    );

    final response = await http.post(
      endpoint,
      headers: {
        'DPoP': dPoPHeader,
      },
      body: {
        'client_id': metadata.clientId,
        'grant_type': 'authorization_code',
        'code': codeParam,
        'redirect_uri': metadata.redirectUris.firstOrNull,
        'code_verifier': context.codeVerifier,
      },
    );

    final tokenJson = jsonDecode(response.body);

    if (response.statusCode == 401 &&
        tokenJson['error'] == 'use_dpop_nonce' &&
        response.headers.containsKey('dpop-nonce')) {
      // Retry with next DPoP nonce
      return await this.callback(
        callback,
        context.copyWith(dpopNonce: response.headers['dpop-nonce']!),
      );
    }

    if (response.statusCode != 200) {
      throw OAuthException(response.body);
    }

    return OAuthSession(
      accessToken: tokenJson['access_token'],
      refreshToken: tokenJson['refresh_token'],
      tokenType: tokenJson['token_type'],
      scope: tokenJson['scope'],
      expiresAt: DateTime.now()
          .toUtc()
          .add(Duration(seconds: tokenJson['expires_in'])),
      sub: tokenJson['sub'],
      $dPoPNonce: response.headers['dpop-nonce']!,
      $publicKey: publicKey,
      $privateKey: privateKey,
    );
  }

  /// Returns a refreshed [session].
  Future<OAuthSession> refresh(final OAuthSession session) async {
    if (session.refreshToken.isEmpty) {
      throw OAuthException('No refresh token available');
    }

    final endpoint = Uri.https(service, '/oauth/token');

    final dPoPHeader = getDPoPHeader(
      clientId: metadata.clientId,
      endpoint: endpoint.toString(),
      method: 'POST',
      dPoPNonce: session.$dPoPNonce,
      publicKey: session.$publicKey,
      privateKey: session.$privateKey,
    );

    final response = await http.post(
      endpoint,
      headers: {
        'DPoP': dPoPHeader,
      },
      body: {
        'client_id': metadata.clientId,
        'grant_type': 'refresh_token',
        'refresh_token': session.refreshToken,
      },
    );

    if (response.statusCode != 200) {
      throw OAuthException(response.body);
    }

    final tokenJson = jsonDecode(response.body);

    return OAuthSession(
      accessToken: tokenJson['access_token'],
      refreshToken: tokenJson['refresh_token'],
      tokenType: tokenJson['token_type'],
      scope: tokenJson['scope'],
      expiresAt: DateTime.now()
          .toUtc()
          .add(Duration(seconds: tokenJson['expires_in'])),
      sub: tokenJson['sub'],
      $dPoPNonce: response.headers['dpop-nonce']!,
      $publicKey: session.$publicKey,
      $privateKey: session.$privateKey,
    );
  }
}
